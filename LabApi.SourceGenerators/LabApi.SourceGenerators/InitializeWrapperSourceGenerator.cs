using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace LabApi.SourceGenerators;

/// <summary>
/// A source generator that creates an attribute `InitializeWrapper` to mark initialization methods.
/// It generates a partial class `PluginLoader` with a method `InitializeWrappers` that calls these marked methods in order of their priority.
/// </summary>
[Generator]
public class InitializeWrapperSourceGenerator : IIncrementalGenerator
{
    private const byte DefaultPriority = 128;

    private const string AttributeName = "InitializeWrapper";

    private static readonly string AttributeSourceCode = $$"""
                                                           // <auto-generated/>

                                                           namespace {{Core.GeneratorNamespace}}
                                                           {
                                                               [{{Core.MethodAttributeUsage}}]
                                                               internal class {{AttributeName}} : System.Attribute
                                                               {
                                                                   /// <summary>
                                                                   /// Marks a method to be called during LabApi startup.
                                                                   /// </summary>
                                                                   /// <param name="priority">The priority of the initialization method. Lower values indicate higher priority.</param>
                                                                   public InitializeWrapper(byte priority = {{DefaultPriority}})
                                                                   {
                                                                   }
                                                               }
                                                           }
                                                           """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{AttributeName}.g.cs", SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        IncrementalValuesProvider<MethodDeclarationSyntax> provider = context.SyntaxProvider
            .CreateSyntaxProvider(predicate: (s, _) => s is MethodDeclarationSyntax, transform: (ctx, _) => GetMethodDeclarationForSourceGen(ctx)).Where(t => t.attributeFound)
            .Select((t, _) => t.Item1);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()), (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static (MethodDeclarationSyntax, bool attributeFound) GetMethodDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        MethodDeclarationSyntax methodDeclarationSyntax = (MethodDeclarationSyntax)context.Node;
        SemanticModel semanticModel = context.SemanticModel;

        foreach (AttributeListSyntax attributeListSyntax in methodDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                ITypeSymbol? attributeTypeSymbol = semanticModel.GetTypeInfo(attributeSyntax).Type;
                if (attributeTypeSymbol != null && attributeTypeSymbol.ToDisplayString() == $"{Core.GeneratorNamespace}.{AttributeName}")
                    return (methodDeclarationSyntax, true);
            }
        }

        return (methodDeclarationSyntax, false);
    }

    private static void GenerateCode(SourceProductionContext context, Compilation compilation, ImmutableArray<MethodDeclarationSyntax> methodDeclarations)
    {
        List<(string call, int priority)> initializeCalls = new ();

        foreach (MethodDeclarationSyntax? methodDeclarationSyntax in methodDeclarations)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(methodDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(methodDeclarationSyntax) is not IMethodSymbol methodSymbol)
                continue;

            string namespaceName = methodSymbol.ContainingNamespace.ToDisplayString();
            string className = methodSymbol.ContainingType.Name;
            string methodName = methodSymbol.Name;

            byte priority = DefaultPriority;

            AttributeData? attribute = methodSymbol.GetAttributes().FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == $"{Core.GeneratorNamespace}.{AttributeName}");
            TypedConstant? onlyArgument = attribute?.ConstructorArguments.FirstOrDefault();
            if (onlyArgument?.Value is byte byteValue)
                priority = byteValue;

            initializeCalls.Add(($"{namespaceName}.{className}.{methodName}();", priority));
        }

        initializeCalls.Sort((x, y) => x.priority.CompareTo(y.priority));

        string code = $$"""
                        // <auto-generated>
                        // This code was generated by a source generator.
                        // Changes to this file will be lost during the next build.
                        // Instead, please modify the methods marked with the [InitializeWrapper] attribute, or the source generator itself.
                        // Methods marked with the [InitializeWrapper] attribute will be called during LabApi startup.
                        // </auto-generated>
                        namespace LabApi.Loader
                        {
                            public static partial class PluginLoader
                            {
                                static partial void InitializeWrappers()
                                {
                        {{string.Join("\n", initializeCalls.Select(call => $"            {call.call} // {call.priority}"))}}
                                }
                            }
                        }
                        """;

        context.AddSource("PluginLoader.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}